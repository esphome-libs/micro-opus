--- a/b/celt/bands.c	2026-01-18 10:55:59
+++ b/celt/bands.c	2026-01-18 10:59:09
@@ -43,6 +43,13 @@
 #include "quant_bands.h"
 #include "pitch.h"

+#ifdef CONFIG_OPUS_ENABLE_QUANT_BANDS_TIMING
+#include "quant_bands_timing.h"
+
+/* Define the global timing statistics variable */
+quant_bands_timing_stats_t g_quant_bands_timing = {0};
+#endif
+
 int hysteresis_decision(opus_val16 val, const opus_val16 *thresholds, const opus_val16 *hysteresis, int N, int prev)
 {
    int i;
@@ -989,6 +996,8 @@
    int i;
    int spread;
    ec_ctx *ec;
+
+   QUANT_BANDS_TIMING_ENTER_RECURSION();

    encode = ctx->encode;
    m = ctx->m;
@@ -1000,6 +1009,7 @@
    cache = m->cache.bits + m->cache.index[(LM+1)*m->nbEBands+i];
    if (LM != -1 && b > cache[cache[0]]+12 && N>2)
    {
+      QUANT_BANDS_TIMING_COUNT_SPLIT_PATH();
       int mbits, sbits, delta;
       int itheta;
       int qalloc;
@@ -1014,7 +1024,9 @@
          fill = (fill&1)|(fill<<1);
       B = (B+1)>>1;

+      QUANT_BANDS_TIMING_COMPUTE_THETA_START();
       compute_theta(ctx, &sctx, X, Y, N, &b, B, B0, LM, 0, &fill ARG_QEXT(&ext_b));
+      QUANT_BANDS_TIMING_COMPUTE_THETA_END();
       imid = sctx.imid;
       iside = sctx.iside;
       delta = sctx.delta;
@@ -1079,6 +1091,7 @@
                MULT32_32_Q31(gain,mid), fill ARG_QEXT(ext_b/2));
       }
    } else {
+      QUANT_BANDS_TIMING_COUNT_BASE_PATH();
 #ifdef ENABLE_QEXT
       int extra_bits;
       int ext_remaining_bits;
@@ -1115,8 +1128,10 @@
                            ARG_QEXT(ctx->ext_ec) ARG_QEXT(extra_bits),
                            ctx->arch);
          } else {
+            QUANT_BANDS_TIMING_ALG_UNQUANT_START();
             cm = alg_unquant(X, N, K, spread, B, ec, gain
                              ARG_QEXT(ctx->ext_ec) ARG_QEXT(extra_bits));
+            QUANT_BANDS_TIMING_ALG_UNQUANT_END();
          }
 #ifdef ENABLE_QEXT
       } else if (ext_b > 2*N<<BITRES)
@@ -1133,6 +1148,7 @@
 #endif
       } else {
          /* If there's no pulse, fill the band anyway */
+         QUANT_BANDS_TIMING_FILL_START();
          int j;
          if (ctx->resynth)
          {
@@ -1170,9 +1186,11 @@
                renormalise_vector(X, N, gain, ctx->arch);
             }
          }
+         QUANT_BANDS_TIMING_FILL_END();
       }
    }

+   QUANT_BANDS_TIMING_EXIT_RECURSION();
    return cm;
 }

@@ -1319,10 +1337,12 @@
    /* Reorganize the samples in time order instead of frequency order */
    if (B0>1)
    {
+      QUANT_BANDS_TIMING_DEINTERLEAVE_START();
       if (encode)
          deinterleave_hadamard(X, N_B>>recombine, B0<<recombine, longBlocks);
       if (lowband)
          deinterleave_hadamard(lowband, N_B>>recombine, B0<<recombine, longBlocks);
+      QUANT_BANDS_TIMING_DEINTERLEAVE_END();
    }

 #ifdef ENABLE_QEXT
@@ -1331,15 +1351,22 @@
    } else
 #endif
    {
+      QUANT_BANDS_TIMING_PARTITION_START();
       cm = quant_partition(ctx, X, N, b, B, lowband, LM, gain, fill ARG_QEXT(ext_b));
+      QUANT_BANDS_TIMING_PARTITION_END();
    }

    /* This code is used by the decoder and by the resynthesis-enabled encoder */
    if (ctx->resynth)
    {
+      QUANT_BANDS_TIMING_RESYNTH_START();
       /* Undo the sample reorganization going from time order to frequency order */
       if (B0>1)
+      {
+         QUANT_BANDS_TIMING_INTERLEAVE_START();
          interleave_hadamard(X, N_B>>recombine, B0<<recombine, longBlocks);
+         QUANT_BANDS_TIMING_INTERLEAVE_END();
+      }

       /* Undo time-freq changes that we did earlier */
       N_B = N_B0;
@@ -1373,6 +1400,7 @@
             lowband_out[j] = MULT16_32_Q15(n,X[j]);
       }
       cm &= (1<<B)-1;
+      QUANT_BANDS_TIMING_RESYNTH_END();
    }
    return cm;
 }
@@ -1595,6 +1623,7 @@
       ARG_QEXT(ec_ctx *ext_ec) ARG_QEXT(int *extra_pulses)
       ARG_QEXT(opus_int32 ext_total_bits) ARG_QEXT(const int *cap))
 {
+   QUANT_BANDS_TIMING_START();
    int i;
    opus_int32 remaining_bits;
    const opus_int16 * OPUS_RESTRICT eBands = m->eBands;
@@ -1680,6 +1709,9 @@

    /* Avoid injecting noise in the first band on transients. */
    ctx.avoid_split_noise = B > 1;
+
+   QUANT_BANDS_TIMING_START_LOOP();
+
    for (i=start;i<end;i++)
    {
       opus_int32 tell;
@@ -1918,5 +1950,8 @@
    }
    *seed = ctx.seed;

+   QUANT_BANDS_TIMING_END_TOTAL();
+   QUANT_BANDS_TIMING_PRINT(100);
+
    RESTORE_STACK;
 }
